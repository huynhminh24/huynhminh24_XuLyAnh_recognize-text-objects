# -*- coding: utf-8 -*-
"""CNN_NDA_train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VTr1WyI_8aR8S6-wTze_I46Qa-jWk3Ye
"""

# Importing necessary libraries
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.utils import to_categorical
from tensorflow import keras
import matplotlib.pyplot as plt
from skimage.feature import hog
from skimage import exposure

import cv2
import numpy as np
from tensorflow.keras.models import load_model

import numpy as np
import matplotlib.pyplot as plt

# Loading the dataset and perform splitting
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Analyzing the shape of the datasets
print("Training data shape:", x_train.shape)  # Shape of training data
print("Training labels shape:", y_train.shape)  # Shape of training labels
print("Testing data shape:", x_test.shape)  # Shape of testing data
print("Testing labels shape:", y_test.shape)  # Shape of testing labels

# Concatenating labels from both training and testing sets
all_labels = np.concatenate((y_train, y_test), axis=0)

# Counting unique labels
unique_labels, counts = np.unique(all_labels, return_counts=True)

# Printing the count of each label
for label, count in zip(unique_labels, counts):
    print(f"Nhãn {label}: {count} mẫu")

# Tính toán tần suất xuất hiện của các nhãn trong tập huấn luyện
label_counts = [0] * 10
for label in y_train:
    label_counts[label] += 1
# Biểu đồ cột trực quan hóa tần suất của các nhãn
labels = [str(i) for i in range(10)]
plt.bar(labels, label_counts)
plt.xlabel('Nhãn')
plt.ylabel('Tần suất')
plt.title('Biểu đồ cột tần suất xuất hiện của các nhãn trong MNIST')
plt.show()

# Displaying some sample images from the dataset
plt.figure(figsize=(10, 10))
for i in range(25):
    plt.subplot(5, 5, i + 1)
    plt.imshow(x_train[i], cmap='gray')
    plt.title(f"Label: {y_train[i]}")
    plt.axis('off')
plt.show()

# Peforming reshaping operation
x_train = x_train.reshape((60000, 28, 28, 1)) / 255.0
x_test = x_test.reshape((10000, 28, 28, 1)) / 255.0
y_train = to_categorical(y_train)
y_test = to_categorical(y_test)

# Xây dựng kiến trúc của mô hình
model = Sequential()

model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))

model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dense(10, activation='softmax'))

# Compile the model
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# Print model summary
model.summary()

# Train the model
model_NDA_SVT = model.fit(x_train, y_train, epochs=80, batch_size=64
                    , validation_data=(x_test, y_test))

test_loss, test_acc = model.evaluate(x_test, y_test)
print('Test Loss:', test_loss)
print('Test accuracy:', test_acc)

model.save('mnist_model_004.h5')